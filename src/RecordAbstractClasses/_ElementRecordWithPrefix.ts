/// <reference path="../!ref.ts" />

abstract class _ElementRecordWithPrefix<NameType extends _String | _DictionaryString> extends _ElementRecord<NameType> {
    private _prefix: _String;
    private _includesPrefixInNBFXArray: boolean;

    public getTagName(): string {
        return this.getPrefix().toNBFXString() + ":" + super.getTagName();
    }

    protected getPrefix(): _String {
        return this._prefix;
    }

    protected savePrefix(prefix: _String): this {
        if (prefix.toString() === "xmlns") {
            throw new Error("\"xmlns\" is not a valid name for prefixes");
        }

        if (typeof prefix === "undefined") {
            throw new Error("Invalid prefix");
        }

        if (prefix.toString().length === 0) {
            throw new Error("Length of prefix must be nonzero");
        }

        this._prefix = prefix;
        return this;
    }

    protected processNBFXArray(arr: Uint8Array): $IConsumeNBFXArrayResult<this> {
        if (!(this.getName() === undefined) ||
            (this._includesPrefixInNBFXArray && !(this.getPrefix() === undefined))) { return null; }


        if (this._includesPrefixInNBFXArray) {
            var prefix: _String = new _String();
            var prefixConsumeResult: $IConsumeNBFXArrayResult<_String> = prefix.consumeNBFXArray(arr);
            arr = prefixConsumeResult.remainingArray;
        }

        var nameConsumeResult: $IConsumeNBFXArrayResult<NameType> = this.processNameFromNBFXArray(arr);
        arr = nameConsumeResult.remainingArray;

        var attributesArrayConsumeResult: $IConsumeNBFXArrayResult<Array<_AttributeRecord<any>>> = _ElementRecord.ConsumeElementAttributesArrayFromNBFXArray(arr);

        if (this._includesPrefixInNBFXArray) {
            this.savePrefix(prefixConsumeResult.object);
        }

        this.saveName(nameConsumeResult.object);
        this.saveAttributes(attributesArrayConsumeResult.object);

        var totalConsumedBytes: number = 0;

        if (this._includesPrefixInNBFXArray) {
            totalConsumedBytes += prefixConsumeResult.consumedBytes;
        }

        totalConsumedBytes += (nameConsumeResult.consumedBytes + attributesArrayConsumeResult.consumedBytes);

        return {
            consumedBytes: totalConsumedBytes,
            remainingArray: attributesArrayConsumeResult.remainingArray,
            object: this
        }
    }

    protected generateNBFXStringRepresentation(radix?: number, escapeXML?: boolean): string {
        var out: string = "<" + this.getPrefix().toNBFXString() + ":" + this.getName().toNBFXString();

        this.getAttributes().forEach((a) => {
            out += a.toNBFXString(escapeXML);
        });

        return out + ">";
    }

    public toNBFXArray(): Uint8Array {
        var prefixBytes: Uint8Array = this.getPrefix().toNBFXArray();
        var nameBytes: Uint8Array = this.getName().toNBFXArray();
        var attributeBytesArray: Array<Uint8Array> = this.getAttributes().map((a) => { return a.toNBFXArray(); });

        var totalAttributesByteLength: number = 0;
        attributeBytesArray.forEach((v) => {
            totalAttributesByteLength += v.byteLength;
        })

        var totalOutArrayByteLength: number = 0;

        if (this._includesPrefixInNBFXArray) {
            totalOutArrayByteLength += prefixBytes.byteLength;
        }

        totalOutArrayByteLength += (nameBytes.byteLength + totalAttributesByteLength);


        // Out array is generated by concat'ing all attributes in 
        var out: Uint8Array = new Uint8Array(totalOutArrayByteLength);

        var offset: number = 0;

        if (this._includesPrefixInNBFXArray) {
            out.set(prefixBytes, offset);
            offset += prefixBytes.byteLength;
        }

        out.set(nameBytes, offset);
        offset += nameBytes.byteLength;

        var attributeIndex: number = 0;
        var attributeBytes: Uint8Array;

        while (offset < totalOutArrayByteLength) {
            attributeBytes = attributeBytesArray[attributeIndex++];
            out.set(attributeBytes, offset);
            offset += attributeBytes.byteLength;
        }

        return out;
    }

    constructor(recordType: number, recordTypeString: string, includesPrefixInNBFXArray: boolean = true) {
        super(recordType, recordTypeString);

        this._includesPrefixInNBFXArray = includesPrefixInNBFXArray;
    }
}